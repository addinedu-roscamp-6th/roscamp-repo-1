#!/usr/bin/env python3
import time
import math
import numpy as np
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_msgs.msg import String
from sensor_msgs.msg import LaserScan

class ObstacleAvoidanceNode(Node):
    def __init__(self):
        super().__init__('obstacle_avoidance_node')

        # Subscriptions
        self.create_subscription(LaserScan, '/scan', self.scan_cb, 10)
        self.create_subscription(String, '/fall_status', self.fall_callback, 10)

        # Publisher
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        # LiDAR distance
        self.d_f = float('nan')
        self.is_fall_detected = False

        # Drive parameters
        self.drive_speed = 0.005  # m/s 전진 속도

        # Obstacle detection
        self.obs_detect_thresh = 0.15  # m 장애물 감지 기준

        # FSM state
        self.state = 'DRIVING'

        # Timer at 200Hz
        self.create_timer(1/200.0, self.control_loop)
        self.get_logger().info("장애물 감지 및 정지 노드 시작.")

    def get_min_dist(self, ranges):
        valid_ranges = ranges[(ranges > 0.0) & ~np.isinf(ranges)]
        return float(np.min(valid_ranges)) if valid_ranges.size > 0 else float('nan')

    def scan_cb(self, msg: LaserScan):
        r = np.array(msg.ranges)
        N = len(r)

        angle_min = msg.angle_min
        angle_increment = msg.angle_increment

        center_index = int((-angle_min) / angle_increment)

        front_span_idx = int(math.radians(30) / angle_increment)

        opp_center_index = (center_index + N//2) % N

        start_idx = (opp_center_index - front_span_idx) % N
        end_idx = (opp_center_index + front_span_idx) % N

        if start_idx < end_idx:
            front_ranges = r[start_idx:end_idx+1]
        else:
            front_ranges = np.concatenate((r[start_idx:], r[:end_idx+1]))

        self.d_f = self.get_min_dist(front_ranges)  # 여기를 꼭 호출해서 업데이트

        self.get_logger().info(f"전방 최소 거리: {self.d_f:.2f} m")

    def control_loop(self):
        """장애물 감지 및 정지를 실행하는 메인 제어 루프입니다."""
        twist = Twist()

        # 장애물 감지 및 정지 로직
        if self.state == 'DRIVING':
            if not math.isnan(self.d_f) and self.d_f < self.obs_detect_thresh:
                self.state = 'STOPPED'
                self.get_logger().info("전방 장애물 감지! 로봇 정지")
                twist.linear.x = 0.0
                twist.linear.y = 0.0
                twist.linear.z = 0.0
                twist.angular.x = 0.0
                twist.angular.y = 0.0
                twist.angular.z = 0.0
            else:
                twist.linear.x = self.drive_speed
                twist.linear.y = 0.0
                twist.linear.z = 0.0
                twist.angular.x = 0.0
                twist.angular.y = 0.0
                twist.angular.z = 0.0

                CORRECTION_ANGULAR = 0.0248  # 라디안/초 단위, 실험적으로 조정 필요

                twist.linear.x = self.drive_speed
                twist.angular.z = CORRECTION_ANGULAR


        elif self.state == 'STOPPED':
            if math.isnan(self.d_f) or self.d_f >= self.obs_detect_thresh:
                self.state = 'DRIVING'
                self.get_logger().info("장애물 사라짐, 주행 다시 시작")
                twist.linear.x = self.drive_speed
                twist.linear.y = 0.0
                twist.linear.z = 0.0
                twist.angular.x = 0.0
                twist.angular.y = 0.0
                twist.angular.z = 0.0
            else:
                twist.linear.x = 0.0
                twist.linear.y = 0.0
                twist.linear.z = 0.0
                twist.angular.x = 0.0
                twist.angular.y = 0.0
                twist.angular.z = 0.0               
                
        # 최종 메시지 발행
        self.cmd_pub.publish(twist)


def main():
    rclpy.init()
    node = ObstacleAvoidanceNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
